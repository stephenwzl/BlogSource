---
title: Understanding Clang AST
date: 2018-01-08 20:07:59
tags:
---

Clang, as the world's best compiler front-end (maybe not one of them), exudes a unique and fascinating charm that makes people unable to resist wanting to learn more about it.
Through this article, you can probably know:

* What is Clang AST
* Clang AST has those things
* How to build LLVM/Clang development environment
* Standing on the shoulders of giants (write a small tool through the functions provided by Clang)

To follow the tutorial in this article, you may need the following basic preparations:

* Have a basic C/C++ programming foundation
* Have used Clang directly or indirectly, and understand what some command-line parameters do
* Have a little abstract programming thinking ability

<!--more-->


# What is Clang AST
Everyone knows that AST (Abstract Syntax Tree) is an indispensable intermediate product in the execution of the compiler front end. The code you write is translated into an abstract tree structure that can be described in a limited language by the compiler front end.
Clang AST has not deviated from this essence, but compared with the AST generated by other compilers, it has a lot of very useful things. These things can make Clang AST behave like ordinary C++ code variables, allowing the operation of AST and slave AST Obtaining information is very, very easy.

However, before we learn more about Clang AST, let us add some AST-related knowledge: how to use AST to represent code?

## Abstract representation of code
The amount of code and writing form are unlimited, but the form that AST can represent is limited. How to express unlimited code in a limited form? this is a problem. So we need to express the code in an abstract form.
In order to find a relatively simple research case, here is an example of enginx's grammatical abstract code:

```c
typedef enum {
  ENGINX_BOOLEAN_VALUE = 1,
  ENGINX_STRING_VALUE,
  ENGINX_INT_VALUE,
  ENGINX_NULL_VALUE,
  ENGINX_IDENTIFIER_VALUE
} ENGINX_VALUE_TYPE;
```

In enginx, I summarize all the types used to represent data into one type: **ENGINX\_VALUE\_TYPE**, which is a simple abstraction, so that when we analyze the syntax, we only need to encounter the basic Data type, we can all summarize it here.
Similarly, in Clang's AST, the representation of type is Type. When specific to the type of a language, it can derive **PointerType** (pointer type), **ObjCObjectType** (objc object type), **BuiltinType ** (built-in basic data types) these representations.
In the definition of Clang, there are three things in the programming language: Type (type), Decl (declaration), Stmt (statement), through the connection, repetition or alternative (alternative) of these three can form a door Programming language. For example, a piece of code in the following figure:

<img src="/images/BNF.png" style="max-width:350px"/>

FunctionDecl and ParmVarDecl are all derived from Decl, and CompoundStmt, ReturnStmt, and DeclStmt are all derived from Stmt. )

As you can see from the figure above, a function of a **FunctionDecl** (implementation of a function) is composed of a **ParmVarDecl** connected to **CompoundStmt**. The **CompoundStmt** of this function is composed of **DeclStmt** and **ReturnStmt**. If we continue to dig deeper, we can also find that the **ParmVarDecl** of this code consists of **BuiltinType** and an identifier literal connection.
Obviously there are many other forms in a programming language, which we can all describe in this way. So from an abstract point of view, a programming language with infinite forms can be expressed in limited forms.

## AST structure
Undoubtedly, the AST structure generated by the actual code must be very complicated, and we can get a glimpse of it. First write a simplest C code file:

```c
// test.c
 int someFunc(int x) {
  int result = x / 42;
  return result;
 }
```

Then, use the ast dump plugin that comes with Clang to view the AST generated by Clang analysis of this C code:

```shell
clang -Xclang -ast-dump -fsyntax-only test.c
```

The result is shown in the figure:

![](/images/ast-dump.png)

As you can see, the top-level structure of Clang AST is called **TranslationUnit**, and we call it "compilation unit". Its child nodes are preceded by many **TypedefDecl**, these are built-in definitions of Clang, you can leave them alone. Then we encountered **FunctionDecl**, the overall structure is basically the same as the diagram we exemplified above, but its level is a bit richer, and the principle is the same, so I won't repeat it.

However, we can see from the Clang AST dump that each syntax node contains a lot of information. For example, the memory address of **FunctionDecl** in the AST is 0x7fecf7017538, which is at <test.c:2:1, line: 5:1> position. What is the use of this information? This is the difference between Clang AST that we will discuss next.

# The role of Clang AST
If you have read the AST source code of enginx, you will find that the AST of enginx is too young too simple. Even searching for a node requires traversing the entire tree. The information carried by each node is only semantics, so enginx can only be based on AST explains and runs, and can't do more.
We can see from the above ast dump that the information contained in each syntax node of Clang AST is very rich. In fact, its richness is far more than imagined, so when we get Clang AST, it will not be like enginx. The AST is so stretched.
In addition to Clang AST having a function in the sense of compiling like a normal compiler, it actually gives ordinary developers the ability to participate in the compilation process. We will show how to use the Clang AST API through a simple example.

## Build LLVM/Clang development environment
There are relatively few practices on the LLVM/Clang development environment on the Internet. We can follow the official documents to follow the instructions:

* checkout the latest LLVM release branch
* Checkout clang to the llvm/tools/clang directory
* checkout clang-tools-extra to the llvm/tools/extra directory
* checkout compiler-rt to the llvm/tools/compiler-rt directory
* Create a build directory
* If you are used to cmake, use the command cmake /path/to/llvm
* If you are used to Xcode, use the command cmake -G Xcode /path/to/llvm

## Example: Symbol-based definition search
First, explain what symbol-based definition search is: When we search for a class definition in the IDE, we basically use symbol-based search (or mixed text matching), which is different from the matching of ordinary text editors. For example, if you click to jump to the definition of a class in Xcode, this is obviously based on symbol analysis. The IDE does not simply match by text. If it is matched by text, it is easy to jump to a comment or a certain place. Approximate sentences.

Obviously, in order to find and locate symbols, we need to use semantic analysis. If enginx (or any other simple program with an AST structure) needs to implement an auxiliary function such as an editor, searching for a symbol can obviously only be achieved by constantly traversing the AST, which is very inefficient, but fortunately the structure of enginx AST is very simple , The overhead of traversal is not high. But this kind of problem is copied to C, C++, Objective-C, and Swift, which are used to build huge applications, with hundreds of thousands of lines of code. The efficiency of repeated traversal is unacceptable.
For this reason, Clang AST encapsulates a lot of very powerful APIs for us to use. We can use these APIs to implement this example: **Find a Class named Demo from the C++ code and give the specific location** .

Sample Code:	

```c++
namespace ClangTutorial {
    class Demo {}
}
```

### Create Project
Create the FindNamedClass folder in `llvm/tools/clang/examples` and add a line at the end of `llvm/tools/clang/examples/CMakeLists.txt`:

```cmake
add_subdirectory(FindNamedClass)
```

Add the main.cpp file in the **FindNamedClass** folder, and add the CMakeLists.txt file, and modify the content as follows:

```cmake
add_clang_executable(findNamedClass main.cpp)
 
target_link_libraries(findNamedClass PRIVATE clangTooling)
```

At this point, our project file has been created, and then we can formally write the code. Before writing, you need to cmake again in your build directory to ensure that the configuration is up to date.

### Clang Tools

Well, at this time we introduced another concept called Clang Tools. Judging from the above CMake configuration, the sample code we are going to write this time is actually a stand-alone command line program that uses the library of **libclangTooling**. Therefore, Clang Tools is a tool that runs independently through the function library provided by Clang. The same type of Clang Tools also has famous tools such as clang-check, clang-fixit, and clang-format.

### RecursiveASTVisitor

Before writing the code, we need to understand such a package provided by the Clang library. When we get the AST provided by Clang, its top-level structure is definitely a "compilation unit". To find a node, we can traverse, but we can also use the access algorithm encapsulated by Clang. The encapsulation of this algorithm is **RecursiveASTVisitor* *. We inherit this class and implement the **VisitCXXRecordDecl**, then this method will be triggered on the node that accesses the **CXXRecordDecl** type. (CXXRecordDecl type is used to represent C++ class/union/struct)

```c++
class FindNamedClassVisitor : public RecursiveASTVisitor&lt;FindNamedClassVisitor&gt; {
public:
  bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
    // 可以 dump一下看看到底有什么
    if (Declaration-&gt;getQualifiedNameAsString() == "ClangTutorial::Demo")
        Declaration-&gt;dump();
    
    // 这个返回值表示是否需要接着访问其他节点
    return true;
  }
};
```

### FrontendAction and ASTConsumer
Earlier, we have implemented **RecursiveASTVisitor**. It is reasonable to realize the core logic of finding symbols based on Clang AST, but it is clear that we need an entry, which needs to define how we get the whole through a compiler instance AST and how to access AST.
**FrontendAction** is something that deals with the compilation instance. The lexical analysis, syntax analysis and other processes are hidden by the compilation instance. The compilation instance will trigger some methods defined by **FrontendAction**, and the details of the compilation process Information tells it, such as which file was compiled, compilation parameters, etc. **ASTConsumer** is actually a sub-process product of **FrontendAction**. In **ASTConsumer**, we can get the entire "compilation unit" and call the previous Visitor to visit and search.

```c++
class FindNamedClassConsumer : public clang::ASTConsumer {
public:
  explicit FindNamedClassConsumer(ASTContext *Context) : Visitor(Context) {}
  virtual void HandleTranslationUnit(clang::ASTContext &amp;Context) {
    // 通过 RecursiveASTVisitor访问 translation unit会遍历 AST所有节点  
    Visitor.TraverseDecl(Context.getTranslationUnitDecl());
  }
private:
  // RecursiveASTVisitor 的具体实现.
  FindNamedClassVisitor Visitor;
};
 
class FindNamedClassAction : public clang::ASTFrontendAction {
public:
  virtual std::unique_ptr&lt;clang::ASTConsumer&gt; CreateASTConsumer(clang::CompilerInstance &amp;Compiler, llvm::StringRef InFile) {
    return std::unique_ptr&lt;clang::ASTConsumer&gt;(new FindNamedClassConsumer(&amp;Compiler.getASTContext()));
  }
}
```

### main function
In order to simplify the problem, we directly call the runToolOnCode method of clangTooling, pass in the code string and start parsing.

```c++
int main(int argc, char **argv) {
    if (argc &gt; 1) {
        clang::tooling::runToolOnCode(new FindNamedClassAction, argv[1]);
    }
}
```

Then we compile and test

```shell
$ ./findNameClass "namespace ClangTutorial { class Demo {}; }"
```

as the picture shows

![](/images/decl-dump.png)

We have been able to find the specified symbol definition and dump it out, but we haven't thought of how to get its location and other information. To solve this problem, we need to introduce another concept.

### ASTContext

In the previous code, we secretly used **ASTContext** but did not introduce it. ASTContext is actually a structure for compiling instances to save all AST information. It mainly includes the symbol table during compilation and the original form of AST. We also get the entire "compilation unit" directly from ASTContext.
With the symbol table, we can get the original definition of the symbol in the AST, but Clang's API has implicitly done this for us:

```c++
if (Declaration->getQualifiedNameAsString() == "ClangTutorial::Demo") {
    FullSourceLoc FullLocation = Context->getFullLoc(Declaration->getLocStart());
    if (FullLocation.isValid())
      llvm::outs() << "Found declaration at "
                   << FullLocation.getSpellingLineNumber() << ":"
                   << FullLocation.getSpellingColumnNumber() << "\n";
}
```

As long as we get the original position of the symbol definition through a few simple API and object encapsulation in the above code, we compile and run it again to get the result:

```shell
Found declaration at 1:27
```

Through the Clang AST API, in addition to obtaining the location of the symbol definition in the source file, we can also obtain the method call relationship, type definition, and source code content, which is very powerful.

# Write at the back
LLVM was designed as a series of libraries at the beginning of its design, as is Clang. Through this series of libraries, developers can implement a variety of powerful functions and play with programming languages. The Clang AST in this article only involves one or two of Clang's libraries. More and more powerful functions can be found in [Clang official documentation](https://clang.llvm.org/docs/index.html).

This article refers to the following articles or websites:

* [Clang 6 documentation/Introduction to the Clang AST](http://clang.llvm.org/docs/IntroductionToTheClangAST.html)
* [Clang doc](https://clang.llvm.org/doxygen)
* [Clang 6 documentation/How to write RecursiveASTVisitor based ASTFrontendActions](http://clang.llvm.org/docs/RAVFrontendAction.html)

Recommended books:

* "Homemade Programming Language" by Maeqiao Kazuya
* "Modern Compiler Implementation in C" (U.S.) by Ampere
* "Compiler" Alfred V. Aho waiting
* "Getting Started with LLVM Core Libraries" by Bruno Cardoso Lopes / Rafael Auler

The complete code example in the attachment:

```c++
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendAction.h"
#include "clang/Tooling/Tooling.h"
 
using namespace clang;
 
class FindNamedClassVisitor: public RecursiveASTVisitor<FindNamedClassVisitor> {
public:
    explicit FindNamedClassVisitor(ASTContext *Context) : Context(Context) {}
    
    bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
        if (Declaration->getQualifiedNameAsString() == "ClangTutorial::Demo") {
            FullSourceLoc FullLocation = Context->getFullLoc(Declaration->getLocStart());
            if (FullLocation.isValid())
                llvm::outs() << "Found declaration at "
                << FullLocation.getSpellingLineNumber() << ":"
                << FullLocation.getSpellingColumnNumber() << "\n";
        }
        return true;
    }
private:
    ASTContext *Context;
};
 
class FindNamedClassConsumer : public clang::ASTConsumer {
public:
    explicit FindNamedClassConsumer(ASTContext *Context) : Visitor(Context) {}
    
    virtual void HandleTranslationUnit(clang::ASTContext &Context) {
        Visitor.TraverseDecl(Context.getTranslationUnitDecl());
    }
private:
    FindNamedClassVisitor Visitor;
};
 
class FindNamedClassAction : public clang::ASTFrontendAction {
public:
    virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(clang::CompilerInstance &Compiler, llvm::StringRef InFile) {
        return std::unique_ptr<clang::ASTConsumer>(new FindNamedClassConsumer(&Compiler.getASTContext()));
    }
};
 
int main(int argc, char **argv) {
    if (argc > 1) {
        clang::tooling::runToolOnCode(new FindNamedClassAction, argv[1]);
    }
}
```
